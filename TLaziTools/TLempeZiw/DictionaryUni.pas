// Lazarus, WIN-10\XP                                 *** DictionaryUni.pas ***

// ****************************************************************************
// * LempeZiw:                                 Обслужить справочник кодов LZW *
// ****************************************************************************

// Автор: Труфанов В.Е.                              Дата создания:  10.10.2017
// Copyright © 2017 tve                              Посл.изменение: 27.10.2017

unit DictionaryUni;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Dialogs;

// По прежнему коду сгенерировать новый
function GenNewCode(OldCode:Integer):Integer;
// Преобразовать подстроку в визуализированное поле словаря (десятичные
// разряды с точкой)
function MakeCodes(const str:String): String;
// Подстроку в паре поле-значение добавить в словарь для сжатия
procedure AddaDiCompress(const s:String; const Code:Integer; var Dict:TStringList);
// Подстроку добавить в словарь распаковки
procedure AddaDiRecover(const cc:String; var Dict:TStringList);
// Выполнить начальное заполнение словаря архивирования, генерировать новый код
function IniCompressDict(var Dict:TStringList): Integer;
// Выделить из значения записи словаря вида "259^^OOB" код
// в визуализированном десятичном виде для записи в выходной файл
function GetCode10(const str:String): String;

// Выполнить начальное заполнение словаря распаковки
function IniRecoverDict(var Dict:TStringList):Integer;
// Выбрать значение по коду из словаря распаковки
function GetRecoverDict(Code:String; var Dict:TStringList): String;

implementation

// ****************************************************************************
// *                    По прежнему коду сгенерировать новый                  *
// ****************************************************************************
function GenNewCode(OldCode:Integer):Integer;
var NewCode:Integer;
begin
  // Задаем новый код, чтобы он не был нулевым по модулю 256,
  // так как младшие 8 нулевых бит не должны получались для записи
  NewCode:=OldCode+1;
  if NewCode mod 256 = 0 then inc(NewCode);
  Result:=NewCode;
end;

// =========================================== Обработка справочника СЖАТИЯ ===

// Записи справочника сжатия кодов LZW сформированы по следующему типу:

//   82.=82^^R
//   254.=254^^ю
//   79.79.66.=259^^OOB

// где, например, "79.79.66." представляет собой последовательность кодов
// символов, генерирующих новый код "259"

// ****************************************************************************
// *          Преобразовать подстроку в визуализированное поле словаря        *
// *                        (десятичные разряды с точкой)                     *
// ****************************************************************************

// "AR" ==> "65.62."

function MakeCodes(const str:String): String;
var
  nPoint: Integer;
  cStru: String;
begin
  cStru:='';
  for nPoint:=1 to length(str) do begin
    cStru:=cStru+IntToStr(ord(str[nPoint]))+'.';
  end;
  Result:=cStru;
end;

// ****************************************************************************
// *                 Подстроку добавить в словарь распаковки                  *
// ****************************************************************************
procedure AddaDiRecover(const cc:String; var Dict:TStringList);
begin
  // Ограничиваем рост словаря на 3840 кодов = 256*15, так как для избежания
  // символов с нулевым кодов, мы всегда в преобразовании делаем +1;
  // А также снимаем коды, дающие остаток по модулю 256 = 0:
  //   256,  512,  768, 1024, 1280, 1536, 1792, 2048
  //  2304, 2560, 2816, 3072, 3328, 3584  = -14
  if Dict.Count<3826 then Dict.Add(cc);
end;

// ****************************************************************************
// *       Подстроку в паре поле-значение добавить в словарь (для сжатия)     *
// ****************************************************************************
procedure AddaDiCompress(const s:String; const Code:Integer; var Dict:TStringList);
var
  cStru,c: String;
begin
  cStru:=MakeCodes(s);
  c:=cStru+'='+IntToStr(Code)+'^^'+s;
  // Ограничиваем рост словаря на 3840 кодов = 256*15, так как для избежания
  // символов с нулевым кодов, мы всегда в преобразовании делаем +1;
  // А также снимаем коды, дающие остаток по модулю 256 = 0:
  //   256,  512,  768, 1024, 1280, 1536, 1792, 2048
  //  2304, 2560, 2816, 3072, 3328, 3584  = -14
  if Dict.Count<3826 then Dict.Add(c);
end;

// ****************************************************************************
// *         Выделить из значения записи словаря вида "259^^OOB" код          *
// *      в визуализированном десятичном виде для записи в выходной файл      *
// ****************************************************************************
function GetCode10(const str:String): String;
var nPoint: Integer;
begin
  Result:='';
  nPoint:=AnsiPos('^^',str);
  if nPoint<>0 then Result:=Copy(str,1,nPoint-1)+'.';
end;

// ****************************************************************************
// *            Выполнить начальное заполнение словаря архивирования          *
// *            и сгенерировать следующий код для заполнения словаря          *
// ****************************************************************************
function IniCompressDict(var Dict:TStringList): Integer;
var i: Integer;
begin
  for i:=0 to 255 do begin
    AddaDiCompress(String(Chr(i)),i,Dict);
  end;
  Result:=GenNewCode(i);
end;

// ======================================= Обработка справочника РАСПАКОВКИ ===

// ****************************************************************************
// *              Выполнить начальное заполнение словаря распаковки           *
// *            и сгенерировать следующий код для заполнения словаря          *
// ****************************************************************************
function IniRecoverDict(var Dict:TStringList):Integer;
var i:Integer; cc:String;
begin
  for i:=0 to 255 do begin
    cc:=IntToStr(i)+'='+chr(i);
    AddaDiRecover(cc,Dict);
  end;
  Result:=GenNewCode(i);
end;

// ****************************************************************************
// *                Выбрать значение по коду из словаря распаковки            *
// ****************************************************************************
function GetRecoverDict(Code:String; var Dict:TStringList): String;
var
  Str: String;
begin
  // Выбираем значение по коду из справочника
  Str:=Dict.Values[Code];
  //Showmessage(CP1251ToUTF8('GetRecoverDict: '+IntToStr(Code)+' ***'+Str+'***'));
  if Str='' then Showmessage('Код не определился!');
  Result:=Str;
end;

end.

// ****************************************************** DictionaryUni.pas ***

